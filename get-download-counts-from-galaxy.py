#!/usr/bin/env python3
"""
This script fetches the download count of an Ansible role from Ansible Galaxy,
writes the count to a JSON file, and generates a bar chart of the download counts
for the last 30 days.
"""
import os.path
import subprocess
import re
import json
import pandas as pd
import matplotlib.pyplot as plt
import logging
import jinja2
import argparse

from datetime import datetime

# Configure the root logger to suppress logs from external libraries
logging.basicConfig(level=logging.WARNING, format='%(asctime)s - %(levelname)s - %(message)s')
# Create a logger for your script
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)


def get_download_count():
    """
    Fetches the download count of the Ansible role 'marcinpraczko.goss-install' from Ansible Galaxy.

    Returns:
        int: The download count if found, otherwise None.
    """
    logger.info("Fetching download count from Ansible Galaxy.")
    try:
        result = subprocess.run(
            ["ansible-galaxy", "role", "info", "marcinpraczko.goss-install"],
            capture_output=True, text=True, check=True
        )
    except subprocess.CalledProcessError as e:
        logger.error("Error running ansible command: %s", e.stderr)
        return None

    match = re.search(r"download_count:\s+(\d+)", result.stdout)
    if match:
        _download_count = int(match.group(1))
        logger.info("Download count fetched successfully: %d", _download_count)
        return _download_count
    else:
        logger.warning("Download count not found in output. Output was: %s", result.stdout)
        return None

def export_df_to_csv(df, csv_file):
    """
    Exports a DataFrame to a CSV file using semicolons as delimiters.

    Args:
        df (pd.DataFrame): The DataFrame to export.
        csv_file (str): Path to save the CSV file.
    """
    logger.info(f"Exporting DataFrame to CSV file: {csv_file}")
    try:
        # Export the DataFrame to a CSV file with semicolons as delimiters
        df.to_csv(csv_file, index=False, sep=';')
        logger.info("CSV file created successfully.")
    except Exception as e:
        logger.error("Error exporting DataFrame to CSV: %s", e)

def convert_json_to_excel(json_file, excel_file):
    """
    Converts a JSON file to an Excel file and adds a new column with the month and year.

    Args:
        json_file (str): Path to the JSON file.
        excel_file (str): Path to save the Excel file.
    """
    logger.info("Converting JSON file to Excel")
    logger.info(f"  JSON file: {json_file}")
    logger.info(f"  Excel file: {excel_file}")
    try:
        # Load JSON data
        with open(json_file, 'r') as file:
            data = json.load(file)

        # Convert JSON data to a pandas DataFrame
        df = pd.DataFrame(data)

        # Convert the 'date' column to a readable date format
        df['date'] = pd.to_datetime(df['date'], format='%Y%m%d')

        # Add a new column with the month and year in MM/YYYY format
        df['month_year'] = df['date'].dt.strftime('%m/%Y')

        # Write the DataFrame to an Excel file
        df.to_excel(excel_file, index=False, sheet_name='Download Counts')

        logger.info("Excel file created successfully.")
    except Exception as e:
        logger.error("Error converting JSON to Excel: %s", e)


def create_pivot_table(df):
    """
    Creates a pivot table from the DataFrame to summarize download counts by month_year.

    Generated by GenAI and manually modified - wondering if this can be optimized.

    Args:
        df (pd.DataFrame): The DataFrame containing the data.

    Returns:
        pd.DataFrame: The pivot table as a DataFrame.
    """

    df = df.sort_values(by='date')


    # Ensure the 'month_year' column is sorted chronologically
    df['month_year'] = pd.to_datetime(df['month_year'], format='%m/%Y')

    # Calculate the monthly download differences
    df['monthly_downloads'] = df['download_count'].diff().fillna(0).astype(int)

    # Convert 'month_year' back to MM/YYYY format for display
    df['month_year'] = df['month_year'].dt.strftime('%m/%Y')

    # Create a pivot table to sum download counts by month_year
    pivot_table = df.pivot_table(
        index='month_year',
        values='monthly_downloads',
        aggfunc='sum',
        margins=True,  # Add a "Total" row
        margins_name='Total Result'  # Name for the "Total" row
    )

    # Rename columns for better readability
    pivot_table = pivot_table.rename(columns={'monthly_downloads': 'Sum - download_count'})

    # Reset the index to make 'month_year' a regular column
    pivot_table = pivot_table.reset_index()

    # Separate the 'Total Result' row
    total_row = pivot_table[pivot_table['month_year'] == 'Total Result']
    pivot_table = pivot_table[pivot_table['month_year'] != 'Total Result']

    # Convert month_year to datetime for sorting
    pivot_table['month_year'] = pd.to_datetime(pivot_table['month_year'], format='%m/%Y')

    # Sort by month_year
    pivot_table = pivot_table.sort_values(by='month_year')

    # Convert month_year back to MM/YYYY format
    pivot_table['month_year'] = pivot_table['month_year'].dt.strftime('%m/%Y')

    # Append the 'Total Result' row back to the bottom
    pivot_table = pd.concat([pivot_table, total_row], ignore_index=True)


    # TODO: Migrate this to separate function - not related with transofrmation but display
    # Display the pivot table with custom formatting
    # logger.info("Pivot table created:")
    # print("+--------------+------------------------+")
    # print("| month_year   |   Sum - download_count |")
    # print("+==============+========================+")
    # for index, row in pivot_table.iterrows():
    #     if index == "Total Result":
    #         print("+--------------+------------------------+")
    #     print(f"| {index:<12} | {row['Sum - download_count']:>22} |")
    # print("+--------------+------------------------+")

    # Return the pivot table as a DataFrame
    return pivot_table

def write_download_count_to_json(_download_count, filename):
    """
    Writes the download count to a JSON file with the current date and time.

    Args:
        _download_count (int): The download count to write.
        filename (str): The name of the JSON file to write to.
    """
    logger.info("Writing download count to JSON file: %s", filename)
    current_date = datetime.now().strftime('%Y%m%d')
    data = {
        'date': current_date,
        'download_count': _download_count
    }

    try:
        with open(filename, 'r+') as file:
            file_data = json.load(file)
            # Check if a record with the current date exists
            for record in file_data:
                if record['date'] == current_date:
                    record['download_count'] = _download_count
                    break
            else:
                file_data.append(data)
            file.seek(0)
            json.dump(file_data, file, indent=4)
        logger.info("Download count written to existing JSON file.")
    except FileNotFoundError:
        with open(filename, 'w') as file:
            json.dump([data], file, indent=4)
        logger.info("JSON file not found. Created new JSON file and wrote download count.")

def load_and_prepare_data(json_file):
    """
    Loads the JSON data and prepares two DataFrames: one for the last 30 days and one for the last 12 months.

    Args:
        json_file (str): The name of the JSON file to read from.

    Returns:
        tuple: A tuple containing two DataFrames:
               - last_30_days_df: DataFrame for the last 30 days.
               - last_12_months_df: DataFrame for the last 12 months.
    """
    logger.info("Loading JSON data from file: %s", json_file)
    with open(json_file, 'r') as file:
        data = json.load(file)
    df = pd.DataFrame(data)
    df['date'] = pd.to_datetime(df['date'], format='%Y%m%d')

    # Prepare data for the last 30 days
    today = datetime.now()
    last_30_days = pd.date_range(end=today, periods=30).strftime('%Y%m%d').tolist()
    last_30_days_df = pd.DataFrame(last_30_days, columns=['date'])
    last_30_days_df['date'] = pd.to_datetime(last_30_days_df['date'], format='%Y%m%d')

    # Determine the default value for the last 30 days
    if not df.empty:
        oldest_value = df['download_count'].iloc[0]
    else:
        oldest_value = 0

    default_value = oldest_value if oldest_value != 0 else df['download_count'].mean()
    last_30_days_df['download_count'] = default_value

    # Merge the data frames for the last 30 days
    merged_30_days_df = pd.merge(last_30_days_df, df, on='date', how='left')
    merged_30_days_df['download_count'] = merged_30_days_df['download_count_y'].fillna(merged_30_days_df['download_count_x'])
    merged_30_days_df = merged_30_days_df[['date', 'download_count']]

    # print(merged_30_days_df)
    return merged_30_days_df

def calculate_monthly_summary(merged_df):
    """
    Calculates the total downloads per month.

    Args:
        merged_df (pd.DataFrame): The merged DataFrame.

    Returns:
        pd.DataFrame: A DataFrame containing the monthly summary.
    """
    logger.info("Calculating monthly summary.")
    # Convert the 'date' column to datetime for grouping
    merged_df['date'] = pd.to_datetime(merged_df['date'], format='%Y%m%d')
    merged_df['month'] = merged_df['date'].dt.to_period('M')  # Extract month as a period

    # Group by month and calculate total downloads
    monthly_summary = merged_df.groupby('month')['download_count'].max().reset_index()
    monthly_summary['month'] = monthly_summary['month'].dt.strftime('%Y-%m')  # Format month as string

    return monthly_summary


def generate_monthly_barchart(monthly_summary, svg_file):
    """
    Generates a bar chart for the monthly summary.

    Args:
        monthly_summary (pd.DataFrame): The DataFrame containing the monthly summary.
        svg_file (str): The name of the SVG file to save the bar chart to.
    """
    logger.info("Generating monthly bar chart and saving to file: %s", svg_file)
    # Create a bar chart (size is in inches)
    fig, ax = plt.subplots(figsize=(12, 6))
    bars = ax.bar(monthly_summary['month'], monthly_summary['download_count'], color='green')

    ax.set_xticks(monthly_summary['month'])
    ax.set_xticklabels(monthly_summary['month'], rotation=45, ha='right')

    ax.set_xlabel('Month')
    ax.set_ylabel('Total Downloads')
    ax.set_title('Monthly Download Summary')

    # Add values on top of each bar
    for bar in bars:
        height = bar.get_height()
        ax.text(bar.get_x() + bar.get_width() / 2, height, f'{int(height)}', ha='center', va='bottom', color='green')

    plt.tight_layout()
    monthly_svg_file = svg_file.replace('.svg', '_monthly.svg')
    plt.savefig(monthly_svg_file, format='svg')
    plt.close()
    logger.info("Monthly bar chart saved as SVG file: %s", monthly_svg_file)


def calculate_statistics(merged_df):
    """
    Calculates the statistics needed for the bar chart.

    Args:
        merged_df (pd.DataFrame): The merged DataFrame.

    Returns:
        tuple: A tuple containing the total downloads and the maximum daily difference.
    """
    # Calculate the difference between consecutive days
    merged_df['download_diff'] = merged_df['download_count'].diff().fillna(0)

    # Calculate the total downloads (latest value)
    total_downloads = merged_df['download_count'].iloc[-1]

    # Calculate the maximum daily difference
    max_daily_diff = merged_df['download_diff'].max()

    return total_downloads, max_daily_diff


def generate_barchart(merged_df, total_downloads, max_daily_diff, svg_file):
    """
    Generates a bar chart from the prepared DataFrame and statistics.

    Args:
        merged_df (pd.DataFrame): The prepared DataFrame.
        total_downloads (int): The total downloads.
        max_daily_diff (float): The maximum daily difference.
        svg_file (str): The name of the SVG file to save the bar chart to.
    """
    logger.info("Generating bar chart and saving to file: %s", svg_file)
    # Create a bar chart (size is in inches)
    fig, ax = plt.subplots(figsize=(15, 8))
    bars = ax.bar(merged_df['date'], merged_df['download_diff'], color='blue')

    ax.set_xticks(merged_df['date'][::2])
    ax.set_xticklabels(merged_df['date'][::2], rotation=45, ha='right')

    ax.set_xlabel('Date')
    ax.set_ylabel('Download Count Difference')
    ax.set_title('Download Count Differences for the Last 30 Days')

    # Add total downloads text to the top-left corner
    ax.text(0.05, 0.95, f'Total Downloads: {total_downloads}', transform=ax.transAxes,
            fontsize=12, verticalalignment='top', horizontalalignment='left', bbox=dict(facecolor='white', alpha=0.5))

    # Add max downloads per day text below total downloads
    ax.text(0.05, 0.90, f'Max downloads per day: {max_daily_diff}', transform=ax.transAxes,
            fontsize=12, verticalalignment='top', horizontalalignment='left', bbox=dict(facecolor='white', alpha=0.5))

    # Add values on top of each bar
    for bar in bars:
        height = bar.get_height()
        ax.text(bar.get_x() + bar.get_width() / 2, height, f'{int(height)}', ha='center', va='bottom', color='blue')

    plt.tight_layout()
    plt.savefig(svg_file, format='svg')
    plt.close()
    logger.info("Bar chart saved as SVG file: %s", svg_file)


def create_barchart_from_json(json_file, svg_file):
    """
    Creates bar charts from the download counts stored in a JSON file, showing daily differences and monthly summaries.

    Args:
        json_file (str): The name of the JSON file to read from.
        svg_file (str): The name of the SVG file to save the bar charts to.
    """
    data_frame = load_and_prepare_data(json_file)
    total_downloads, max_daily_diff = calculate_statistics(data_frame)

    # Generate daily bar chart
    generate_barchart(data_frame, total_downloads, max_daily_diff, svg_file)

def create_barchart_from_df(df, svg_file):
    """
    Creates a bar chart from a DataFrame containing monthly download data.

    Args:
        df (pd.DataFrame): The DataFrame containing the monthly download data.
                           It should have two columns: 'month_year' and 'Sum - download_count'.
        svg_file (str): The path to save the generated SVG file.
    """
    logger.info("Generating bar chart for monthly downloads and saving to file: %s", svg_file)

    # Remove the 'Total Result' row
    df = df[df['month_year'] != 'Total Result']

    # Create a bar chart
    fig, ax = plt.subplots(figsize=(15, 8))
    bars = ax.bar(df['month_year'], df['Sum - download_count'].astype(int), color='blue')

    # Set chart labels and title
    ax.set_xlabel('Month/Year')
    ax.set_ylabel('Download Count')
    ax.set_title('Monthly Download Counts')

    # Rotate x-axis labels for better readability
    ax.set_xticks(df['month_year'])
    ax.set_xticklabels(df['month_year'], rotation=45, ha='right')

    # Add values on top of each bar
    for bar in bars:
        height = bar.get_height()
        ax.text(bar.get_x() + bar.get_width() / 2, height, f'{height}', ha='center', va='bottom', fontsize=10)

    # Save the bar chart as an SVG file
    plt.tight_layout()
    plt.savefig(svg_file, format='svg')
    plt.close()
    logger.info("Bar chart saved as SVG file: %s", svg_file)


if __name__ == '__main__':
    svg_filename_daily_last30 = 'docs/download_counts_daily.svg'
    svg_filename_monthly      = 'docs/download_counts_monthly.svg'
    json_filename             = 'data/download_counts.json'
    excel_filename            = 'data/download_counts.xlsx'
    csv_file                  = 'data/download_counts.csv'

    template_filename = 'templates/download_stats_page.html.j2'
    html_filename = 'docs/index.html'

    parser = argparse.ArgumentParser(description='Process download counts.')
    parser.add_argument('--fetch', action='store_true', help='Fetch the download count from Ansible Galaxy')
    args = parser.parse_args()

    if args.fetch:
        download_count = get_download_count()
        if download_count is not None:
            write_download_count_to_json(download_count, json_filename)
        else:
            logger.error("Download count not available.")
            exit(1)

    # Helper function to convert JSON to Excel/CSV
    convert_json_to_excel(json_filename, excel_filename)
    df = pd.read_excel(excel_filename)
    export_df_to_csv(df, csv_file)
    pivot_df = create_pivot_table(df)

    create_barchart_from_json(json_file=json_filename, svg_file=svg_filename_daily_last30)
    create_barchart_from_df(pivot_df, svg_filename_monthly)
